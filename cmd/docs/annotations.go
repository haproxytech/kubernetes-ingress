// Copyright 2019 HAProxy Technologies LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"fmt"
	"log"
	"sort"
	"strings"

	"github.com/google/renameio"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

var header = `
This is autogenerated from [doc.yaml](doc.yaml). Description can be found in [generator readme](gen/README.md)

### Custom annotations

more info about custom annotations can be found in [annotations-custom.md](annotations-custom.md)

### Available annotations

> :information_source: Ingress and service annotations can have ` + "`ingress.kubernetes.io`, `haproxy.org` and `haproxy.com`" + ` prefixes
>
> Example: ` + "haproxy.com/ssl-redirect` and `haproxy.org/ssl-redirect`" + ` are same annotation

| Annotation | Type | Default | Dependencies | Config map | Ingress | Service |
| - |:-:|:-:|:-:|:-:|:-:|:-:|
`

var tableFooter = `
> :information_source: Annotations have hierarchy: ` + "`default` <- `Configmap` <- `Ingress` <- `Service`" + `
>
> Service annotations have highest priority. If they are not defined, controller goes one level up until it finds value.
>
> This is useful if we want, for instance, to change default behaviour, but want to keep default for some service. etc.
>
> In general annotations follow the following rules:
> - global  annotations can only be used in Configmap
> - ingress annotations can be used in Ingress and ConfigMap (to configure all ingress resources in use)
> - service annotations can be used in Service, Ingress (to configure all services used in Ingress) and ConfigMap (to configure all services in use)


### Options

#### Global Options

Global options are set via ConfigMap ([--configmap](controller.md)) annotations.
Depending on the option, it can be in Global or Default HAProxy section.

`

var docFooter = `
### Secrets

#### tls-secret

- define through pod arguments
  - ` + "`--default-ssl-certificate`=\\<namespace\\>/\\<secret\\>" + `
- Annotation ` + "`ssl-certificate` in config map" + `
  - \<namespace\>/\<secret\>
  - this replaces default certificate
- certificate can be defined in Ingress object: ` + "`spec.tls[].secretName`" + `
- single certificate secret can contain two items:
  - tls.key
  - tls.crt
- certificate secret with ` + "`rsa` and `ecdsa` certificates:" + `
  - :information_source: only one certificate is also acceptable setup
  - rsa.key
  - rsa.crt
  - ecdsa.key
  - ecdsa.crt

### Data types

#### Port

- value between <0, 65535]

#### Sample expression

- Sample expressions/fetches are used to retrieve data from request/response buffer.
- Example:
  - headers: ` + "`hdr(header-name)`" + `
  - cookies: ` + "`cookie(cookie-name)`" + `
  - Name of the cipher used to offload SSL: ` + "`ssl_fc_cipher`" + `
- Sample expressions are covered in depth in [HAProxy documentation](https://cbonte.github.io/haproxy-dconv/2.0/configuration.html#7.3), however many are out of the ingress controller's scope.

#### Time

- number + type
- in milliseconds, "s" suffix denotes seconds
- example: "1s"
`

func (c *Conf) generateReadmeAnnotations() {
	var buff strings.Builder
	buff.WriteString(title)
	buff.WriteString(c.ActiveVersion.String())
	buff.WriteString(header)

	groups := map[string]struct{}{}
	for _, ann := range c.Items {
		if !ann.VersionMax.LowerOrEqual(c.ActiveVersion) {
			continue
		}
		devVersion := !ann.VersionMin.LowerOrEqual(c.ActiveVersion)
		// log.Println(ann.Title, ann.VersionMin, ">", c.ActiveVersion, devVersion)
		if ann.Group == "" {
			ann.Group = ann.Title
		}
		annType := ann.Type
		if ann.Type == "bool" {
			annType = `[bool](#bool)`
		}
		defaultValue := ann.Default
		if annType != "number" && ann.Default != "" {
			defaultValue = `"` + ann.Default + `"`
		}
		dev := ""
		if devVersion {
			dev = " :construction:(dev)"
		}
		groupLink := strings.ReplaceAll(ann.Group, " ", "-")
		// log.Println(ann.Group, groupLink)
		// 3 can be a link to type maybe like for [IPs or CIDRs](#access-control)?
		buff.WriteString(fmt.Sprintf("| [%s](#%s)%s | %s | %s | %s |%s|%s|%s|\n",
			ann.Title, groupLink, dev, annType, defaultValue, ann.Dependencies,
			Contains(ann.AppliesTo, "configmap"), Contains(ann.AppliesTo, "ingress"), Contains(ann.AppliesTo, "service")))

		// write group
		groups[ann.Group] = struct{}{}
	}

	buff.WriteString(tableFooter)

	sortedGroups := []string{}
	for group := range groups {
		sortedGroups = append(sortedGroups, group)
	}
	sort.Strings(sortedGroups)
	caser := cases.Title(language.Und)
	for _, group := range sortedGroups {
		buff.WriteString(fmt.Sprintf("#### %s\n\n", strings.ReplaceAll(caser.String(group), "-", " ")))
		groupData, haveGroupData := c.Groups[group]
		if haveGroupData && groupData.Header != "" {
			buff.WriteString(groupData.Header)
			buff.WriteString("\n\n")
		}
		for _, ann := range c.Items {
			if ann.Group != group {
				continue
			}
			buff.WriteString(fmt.Sprintf("##### `%s`\n\n", ann.Title))
			if !ann.VersionMin.LowerOrEqual(c.ActiveVersion) {
				buff.WriteString("\n  > :construction: this is only available from next version, currently available in dev build\n\n")
			}
			for _, desc := range ann.Description {
				buff.WriteString(fmt.Sprintf("  %s\n", desc))
			}
			buff.WriteString("\n  Available on:")
			for _, app := range ann.AppliesTo {
				buff.WriteString(fmt.Sprintf("  `%s`", app))
			}
			buff.WriteString("\n")
			for _, tip := range ann.Tip {
				buff.WriteString(fmt.Sprintf("\n  :information_source: %s\n", tip))
			}
			buff.WriteString("\nPossible values:\n\n")
			for _, value := range ann.Values {
				buff.WriteString(fmt.Sprintf("- %s\n", writeValue(value, ann.Default)))
			}
			buff.WriteString("\n")
			selectExamples(ann, &buff)
		}
		if haveGroupData && groupData.Footer != "" {
			buff.WriteString(groupData.Footer)
			buff.WriteString("\n\n")
		}
		buff.WriteString("<p align='right'><a href='#available-annotations'>:arrow_up_small: back to top</a></p>\n\n***\n\n")
	}

	buff.WriteString(docFooter)

	err := renameio.WriteFile("../../documentation/annotations.md", []byte(buff.String()), 0o644)
	if err != nil {
		log.Println(err)
	}
}
